# 一场惊心动魄的"删库"与恢复实录

> 作为站长，最怕的莫过于"删库跑路"，更可怕的是自己亲手删掉了四万多条数据。这是一个真实的删库与恢复的故事。

## 惨案发生

昨天，我在对博客的访客统计插件进行例行维护时，想优化一下"清理历史记录"功能。之前的功能逻辑有些模糊，我希望它能精确地从最早的记录开始删除指定天数的数据。

具体来说，我想把功能改成：当输入"3"并点击清理按钮时，插件会从最早的那天开始，删除接下来3天内的访客记录。这看起来是个很简单的功能。

但是，程序的理解和我的意图存在偏差。当我输入"3"并点击按钮时，它实际执行的操作是"删除3天前的所有记录"。在我还没反应过来的时候，整个博客**超过四万条**的访客记录就这样灰飞烟灭了，只剩下最近3天的几百条记录。

那一刻的感觉，相信经历过数据丢失的朋友都懂。

## 急中生智

冷静下来后，我意识到这是一场灾难，但并非无法挽回。因为我有两个优势：

1. 服务器配置了**每日自动备份**MySQL数据库
2. 备份是按天存储的，没有被覆盖

然而，恢复过程远比预想的复杂：

### 第一次尝试：直接使用PHP脚本

我首先尝试写了一个PHP脚本，企图直接从备份中恢复`visitor_log`表。但是运行后，浏览器竟然报错"内容编码错误"。原因是服务器配置了Gzip压缩，与脚本的输出产生了冲突。

### 第二次尝试：禁用压缩的脚本

我改进脚本，禁用了所有可能的输出压缩，但又遇到了更严重的问题：PHP的`open_basedir`安全限制。这个限制使得PHP脚本无法访问备份目录中的文件。

```php
Warning: file_exists(): open_basedir restriction in effect. 
File(/www/backup/database/mysql/crontab_backup/blog_ybyq_wang/...) 
is not within the allowed path(s): (/www/wwwroot/blog.ybyq.wang/:/tmp/:/proc/:/www/php_session/blog.ybyq.wang/)
```

### 最终解决方案

在多次尝试后，我意识到解决问题的最简单方法是：**绕过限制，而不是与限制对抗**。

1. 首先，我将备份文件**复制到网站根目录**，这样PHP脚本就能访问它了：
   ```bash
   cp /www/backup/database/mysql/crontab_backup/blog_ybyq_wang/blog_ybyq_wang_2025-06-19_02-00-03_mysql_data.sql /www/wwwroot/blog.ybyq.wang/
   ```

2. 然后创建一个**独立的PHP脚本**，直接连接数据库并执行备份恢复：
   ```php
   // 禁用输出压缩
   if (function_exists('apache_setenv')) {
       apache_setenv('no-gzip', '1');
   }
   // 数据库配置
   $db_config = array(
       'host' => 'localhost',
       'database' => 'blog_ybyq_wang'
   );
   // 获取备份文件内容
   $backup_file = $_SERVER['DOCUMENT_ROOT'] . '/blog_ybyq_wang_2025-06-19_02-00-03_mysql_data.sql';
   // 提取INSERT语句并执行
   ```

3. 最后，**使用事务**批量恢复数据，提高效率：
   ```php
   $pdo->beginTransaction();
   foreach ($insert_statements as $sql) {
       $pdo->exec($sql);
       // 每1000条提交一次
       if ($success_count % 1000 == 0) {
           $pdo->commit();
           $pdo->beginTransaction();
       }
   }
   $pdo->commit();
   ```

脚本运行后，数据恢复成功！我的五万条访客记录都回来了。虽然出现了一些主键冲突的错误（因为部分数据已存在），但不影响整体恢复效果。

## 经验教训

这次事件给我的教训深刻而宝贵：

1. **数据无价，备份先行**：自动备份是救命稻草，定期检查备份是否正常也很重要
2. **谨慎操作，测试先行**：重大变更应先在测试环境验证，不要在生产环境直接操作
3. **描述需求要精准**：与人或AI协作时，清晰明确地表达需求至关重要
4. **了解环境限制**：注意服务器安全设置如`open_basedir`等限制，它们可能会阻碍恢复过程
5. **保持冷静，找到绕过方法**：技术问题往往有多种解决思路，绕过障碍有时比硬碰硬更有效

最后，我还对插件进行了全面升级，发布了V2.1.0版本，不仅修复了清理功能的逻辑，还增加了IP模糊匹配、优化了统计图表，提升了整体用户体验。

这是一次惊心动魄的意外，但也让我对数据安全和灾难恢复有了更深的理解。希望我的经历能给各位站长朋友带来一些启发，避免类似的事故发生。

记住：删库不跑路，恢复有方法！ 